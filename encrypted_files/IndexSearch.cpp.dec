#include "Index.h"
#include <algorithm>

int intersect(std::vector<int> &a, const std::vector<int> &b) {
   YELLF(SEARCH,"#a=");YELLVEC(SEARCH, a); YELLF(SEARCH,"#b="); YELLVEC(SEARCH, b);

   if(a.empty() || b.empty()) {return 0;}
   unsigned int i=0,j=0,k=0;
   while(true) {
      if(b[j]<a[k]) {++j; if(j>=b.size()) {YELLF(SEARCH, "#0i="<<i<<"\n"); return i;}}
      if(a[k]<b[j]) {++k; if(k>=a.size()) {YELLF(SEARCH, "#1i="<<i<<"\n"); return i;}}
      //now a[k]==b[j]
      a[i++]=a[k++]; YELLF(SEARCH, "#i="<<i<<"#k="<<k<<"\n");
      ++k; ++j;
      if(k>=a.size()) {YELLF(SEARCH, "#2i="<<i<<"\n"); return i;}
      if(j>=b.size()) {YELLF(SEARCH, "#3i="<<i<<"\n"); return i;}
   }
}

class CountComp {
public:
   std::unordered_map<std::string, unsigned int> *countsptr;
   CountComp(Index &i) {countsptr = &(i.counts);}
   bool operator()(const std::string &a, const std::string &b) {
      ASSRT((*countsptr)[a]!=0 && (*countsptr)[b]!=0, "Can't compare counts of unbeforeseen keywords");
      return (*countsptr)[a] < (*countsptr)[b];
   }
};

void Index::search_message(std::vector<std::string> keywords,
                           std::vector<int> &matches) {
   ASSRT(!keywords.empty(), "Must specify >=1 keyword to search for.");
   //^^QUESTION: can this be empty? if so, return all indices?
   CountComp CC(*this);
   std::sort(keywords.begin(), keywords.end(), CC); // consider least frequent words first
   matches = mentions[keywords[0]];
   YELLVEC(SEARCH, matches);
   for(unsigned int i=1; i<keywords.size(); ++i) {
      YELLVEC(SEARCH, mentions[keywords[i]]);
      int newsize = intersect(matches, mentions[keywords[i]]);
      matches.resize(newsize);
   }
}

void Index::search_category(std::string keyword,
                            std::vector<int> &matches) {
   matches = categories[keyword];
}

void Index::search_times(std::string time1, std::string time2,
                         std::vector<int> &matches) {
   auto lb = std::lower_bound(times.begin(), times.end(), std::pair<long unsigned int, int> (time_to_num(time1),0), T);
   auto ub = std::upper_bound(times.begin(), times.end(), std::pair<long unsigned int, int> (time_to_num(time2),0), T); // ok to have 0 instead of infinity.
   matches.clear();
   for(auto i=lb; i!=ub; ++i) {
      matches.push_back((*i).second);
   }
}
