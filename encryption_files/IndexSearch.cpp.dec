#include "Index.h"
#include <algorithm>

int intersect(std::vector<int> &a, const std::vector<int> &b) {
   if(a.empty() || b.empty()) {return 0;}
   unsigned int i=0,j=0,k=0;
   while(true) {
      if(b[j]<a[k]) {++j; if(j>=b.size()) {return i;}}
      if(a[k]<b[j]) {++k; if(k>=a.size()) {return i;}}
      //now a[k]==b[j]
      a[i++]=a[k++];
      if(k>=a.size()) {return i;}
   }
}

class CountComp {
public:
   std::unordered_map<std::string, unsigned int> *countsptr;
   CountComp(Index &i) {countsptr = &(i.counts);}
   bool operator()(const std::string &a, const std::string &b) {
      ASSRT((*countsptr)[a]!=0 && (*countsptr)[b]!=0, "Can't compare counts of unbeforeseen keywords");
      return (*countsptr)[a] < (*countsptr)[b];
   }
};

void Index::search_message(std::vector<std::string> keywords,
                           std::vector<int> &matches) {
   ASSRT(!keywords.empty(), "Must specify >=1 keyword to search for.");
   //^^QUESTION: can this be empty? if so, return all indices?
   CountComp CC(*this);
   std::sort(keywords.begin(), keywords.end(), CC); // consider least frequent words first
   matches = mentions[keywords[0]];
   for(auto j: matches) {
         YELL(j<<"---");
   }YELL("\n");
   for(unsigned int i=1; i<keywords.size(); ++i) {
      for(auto j: mentions[keywords[i]]) {
         YELL(j<<"---");
      }YELL("\n");
      int newsize = intersect(matches, mentions[keywords[i]]);
      matches.resize(newsize);
   }
}
